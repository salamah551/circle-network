/**
 * Apply Engine - Applies changes with safety checks and approvals
 */

import { ApplyResult, Change, ChangePolicy, ConnectorConfig, DesiredState } from './types';
import { AuditEngine } from './audit-engine';
import { GitHubConnector } from './connectors/github';

export class ApplyEngine {
  private auditEngine: AuditEngine;
  private changePolicy: ChangePolicy;
  private connectors: Map<string, any> = new Map();
  private githubConnector?: GitHubConnector;

  constructor(
    desiredState: DesiredState,
    changePolicy: ChangePolicy,
    config: ConnectorConfig
  ) {
    this.auditEngine = new AuditEngine(desiredState, config);
    this.changePolicy = changePolicy;

    // Store connectors for apply operations
    this.connectors = (this.auditEngine as any).connectors;
    
    if (config.github) {
      this.githubConnector = new GitHubConnector(config.github, desiredState);
    }
  }

  /**
   * Apply a single change
   */
  async applyChange(change: Change): Promise<ApplyResult> {
    // Verify approval if required
    if (change.requiresApproval && change.approvalStatus !== 'approved') {
      return {
        changeId: change.id,
        success: false,
        message: 'Change requires approval',
        error: 'APPROVAL_REQUIRED',
      };
    }

    // Check if auto-apply is allowed for this scope
    const scope = change.scope;
    const autoApplyAllowed = (this.changePolicy.autoApplyAllowed as any)[scope];

    if (change.risk === 'destructive' || change.risk === 'high') {
      if (!autoApplyAllowed) {
        return this.generatePR(change);
      }
    }

    // Get connector for this scope
    const connector = this.connectors.get(scope);
    if (!connector) {
      return {
        changeId: change.id,
        success: false,
        message: `No connector found for scope: ${scope}`,
        error: 'NO_CONNECTOR',
      };
    }

    // Execute change actions
    const results: ApplyResult[] = [];
    
    for (const action of change.actions) {
      try {
        if (action.type === 'api') {
          const result = await connector.apply(change.id, action.payload);
          results.push({
            changeId: change.id,
            success: result.success,
            message: result.message,
            prUrl: result.prUrl,
          });
        } else if (action.type === 'pr' || action.type === 'sql') {
          // Generate PR for these types
          return this.generatePR(change);
        }
      } catch (error: any) {
        results.push({
          changeId: change.id,
          success: false,
          message: `Error applying action: ${error.message}`,
          error: error.message,
        });
      }
    }

    // Return the last result or aggregate
    return results.length > 0 ? results[results.length - 1] : {
      changeId: change.id,
      success: false,
      message: 'No actions executed',
    };
  }

  /**
   * Generate a GitHub PR for a change
   */
  private async generatePR(change: Change): Promise<ApplyResult> {
    if (!this.githubConnector) {
      return {
        changeId: change.id,
        success: false,
        message: 'GitHub connector not configured',
        error: 'NO_GITHUB',
      };
    }

    const files: Array<{ path: string; content: string }> = [];

    // Generate files based on change type
    for (const action of change.actions) {
      if (action.type === 'sql') {
        // Generate SQL migration file
        const timestamp = new Date().toISOString().replace(/[-:]/g, '').split('.')[0];
        const filename = `${timestamp}_ops_${change.id.replace(/\./g, '_')}.sql`;
        files.push({
          path: `supabase/migrations/${filename}`,
          content: action.payload.sql || '-- Generated migration\n',
        });
      } else if (action.type === 'file') {
        files.push({
          path: action.payload.path,
          content: action.payload.content,
        });
      }
    }

    // Generate PR title and body
    const title = `[Ops] ${change.description}`;
    const body = `
## Automated Ops Change

**Change ID:** ${change.id}
**Risk Level:** ${change.risk}
**Scope:** ${change.scope}

### Description
${change.description}

### Actions
${change.actions.map(a => `- ${a.description}`).join('\n')}

### Review Notes
${change.requiresApproval ? '⚠️ This change requires manual review and approval.' : 'This change is low-risk and can be auto-merged after CI passes.'}

---
*Generated by AI Ops Control Plane*
    `.trim();

    // Create PR
    const result = await this.githubConnector.createPR(title, body, files);

    return {
      changeId: change.id,
      success: result.success,
      message: result.message,
      prUrl: result.prUrl,
      error: result.success ? undefined : result.message,
    };
  }

  /**
   * Batch apply multiple changes
   */
  async applyChanges(changes: Change[]): Promise<ApplyResult[]> {
    const results: ApplyResult[] = [];

    for (const change of changes) {
      const result = await this.applyChange(change);
      results.push(result);
    }

    return results;
  }

  /**
   * Log a change to audit log
   */
  private async logChange(change: Change, result: ApplyResult): Promise<void> {
    // In production, this would write to a database table
    // For now, just console log
    console.log('[Ops Audit Log]', {
      timestamp: new Date().toISOString(),
      changeId: change.id,
      scope: change.scope,
      type: change.type,
      risk: change.risk,
      success: result.success,
      message: result.message,
      approvedBy: change.approvedBy,
    });
  }
}
